[{"categories":["python"],"content":"YOLO算法 yolo目标检测算法是you only look once,图片只需要被检测一次就可以出结果 ","date":"2021-05-16","objectID":"/posts/yolo/:0:0","tags":["yolo"],"title":"YOLO","uri":"/posts/yolo/"},{"categories":["Linux"],"content":"vim宏的使用 使用vim的宏可以对单个文件或多个文件进行批量处理，这里记录使用宏的一个样例 我需要更改Annotations文件夹下的1426个xml中的path标签将其中的路径改为自己的，手动更改1426次是不敢想的事情，这里使用vim宏进行处理 首先使用next打开这1426个xml文件 vim next *.xml :bn进入下一个文件，:bp进入上一个文件,这里执行进入下一个文件 :bn 开始录制宏,normal模式按下q再按z,就开始录制一个名字为z的宏 搜索path标签所在行,执行 /path 回车跳转到匹配的第一个path,不想匹配第一个path可以在normal模式下使用n跳转下一个path,使用N跳转上一个path 删除当前行,normal模式下执行 cc 在当前行输入你要替换的内容 \u003cpath\u003eC:\\Users\\y2010\\Desktop\\Annotations\u003c/path\u003e 保存 :w 跳转到下一个文件 bn 结束宏的录制,按下q 接下来执行刚录制的宏,normal模式输入1426@z,就会执行1426次刚录制的宏,完成目录变更的操作,优雅的处理方式! ","date":"2021-05-14","objectID":"/posts/vim/:0:0","tags":["vim"],"title":"Vim宏的使用","uri":"/posts/vim/"},{"categories":["python"],"content":"flask搭建web应用 ","date":"2021-05-13","objectID":"/posts/flask/:0:0","tags":["flask"],"title":"Flask","uri":"/posts/flask/"},{"categories":["python"],"content":"应用简介 这是一个目标检测系统,登录成功后,菜单栏有4个功能,图像预测,图像检测,图像分割,视频中的目标检测,主要使用 python 的 flask web框架 和 imageai目标检测库 图像预测(Image Prediction): 向该系统上传一张图片,系统接受图片后会将图片传入卷积神经网络,最后输出图片中的对象名和概率 目标检测(Image Detection): 向该系统上传一个图片,系统会将图片传入卷积神经网络,最后输出图片中的对象名和概率,并将对象框选出来生成新的图片显示出来 图像分割(Image Extract): 向该系统上传一个图片,系统会将图片传入卷积神经网络,最后输出图片中的对象名和概率,并将对象分割出来生成新的图片,并把这些分割出来的对象图片显示出来 视频检测(Vedio Detection): 向该系统上传一个视频,系统会将该视频传入卷积神经网络,最后输出一个新的视频,新的视频中有对检测到的目标的框选 ","date":"2021-05-13","objectID":"/posts/flask/:1:0","tags":["flask"],"title":"Flask","uri":"/posts/flask/"},{"categories":["python"],"content":"运行环境 windows10系统 python版本： 3.7.8 需要的pip包已经导出到requirements.txt文件，在项目文件夹根目录下进入cmd，执行以下命令就可以安装(要在后面讲到的创建虚拟环境后再安装) python -m pip install -r requirements.txt 导出pip包列表的命令 pip freeze \u003e requirements.txt 这里的tensorflow是cpu版本,如果你电脑安装了cuda和cudnn你可以安装tensorflow的gpu版本,运行速度会更快 pip install tensorflow-gpu==2.4.0 ","date":"2021-05-13","objectID":"/posts/flask/:2:0","tags":["flask"],"title":"Flask","uri":"/posts/flask/"},{"categories":["python"],"content":"搭建过程 ","date":"2021-05-13","objectID":"/posts/flask/:3:0","tags":["flask"],"title":"Flask","uri":"/posts/flask/"},{"categories":["python"],"content":"创建虚拟环境 虚拟环境可以为每一个项目安装独立的 Python 库，这样就可以隔离不同项目之间的 Python 库，也可以隔离项目与操作系统之间的 Python 库,避免发生冲突 新建一个文件夹project,cmd进入这个文件夹执行 py -3 -m venv venv 接着激活这个虚拟环境,执行 venv\\Scripts\\activate 安装项目需要的依赖环境,执行 python -m pip install -r requirements.txt 创建flask的static目录和templates目录,最后的目录结构如下: ","date":"2021-05-13","objectID":"/posts/flask/:3:1","tags":["flask"],"title":"Flask","uri":"/posts/flask/"},{"categories":["python"],"content":"前后端实现 flask的hello world实现 新建一个app.py,到flask官网复制hello world代码 from flask import Flask app = Flask(__name__) @app.route('/') def hello_world(): return 'Hello, World!' 在vscode中打开cmd，设置开发模式并启动flask服务器 set FLASK_APP=app.py set flask_env=development flask run ctrl点击本地url就可以在浏览器看到 Hello world! 路由的实现 使用 route() 来把函数绑定到 url ,由于 html 引用的 css 和 js 放在 staitc 目录, html 在 templates 目录,需要配置 static_url_path 导入对应的包 定义 user 类,生成一个user对象用于登录,登录后信息写入session,如果下次登录前根据email找到了就将信息写入全局对象g 根目录会重定向到 login 函数处理登录,输入的邮箱和密码符合后台设置的就跳转到 index.html,否则重定向到当前页面 index处理时如果没有全局对象g,那就重定向页面到 login 处理 from flask import Flask from flask import render_template, request, redirect,url_for,session,g from dataclasses import dataclass import os app = Flask(__name__, static_url_path=\"/\") app.config['SECRET_KEY'] = \"sldjfsdf32kdf\" @dataclass class User: email: str password: str users = [ User(\"2010059016@qq.com\",\"123\") ] @app.before_request def before_request(): g.user = None if 'email' in session: user = [u for u in users if u.email==session['email']][0] g.user = user @app.route('/') def hello_world(): return redirect(url_for('login')) @app.route('/login', methods=['GET', 'POST']) def login(): if request.method == 'POST': session.pop('email',None) email = request.form.get('email',None) password = request.form.get('password',None) user = [u for u in users if u.email==email] if len(user) \u003e 0: user = user[0] if user and user.password == password: session['email'] = email return redirect('index') return render_template('login.html') @app.route('/index') def index(): if not g.user: return redirect(url_for('login')) return render_template('index.html') 登录页面 登录成功后会跳转到 index.html ,这也是系统的首页 4个功能实现过程都类似,这里选择图像检测进行说明 你会在 image_predection.html 中上传图片,设置 post 请求和 enctype ,不然 flask 接受不了文件,将 aciton 设置为后台路由,由路由绑定的函数处理 \u003cform method=\"post\" action= \"/detection_upfile\" enctype = multipart/form-data class=\"formfile\"\u003e \u003cinput type=\"file\" name=\"file\" style=\"margin:20px 0;\" accept=\"image/*\" id=\"file\" /\u003e \u003cinput type=\"submit\" value=\"上传\" style=\"margin:20px 0;margin-left: 170px;\" /\u003e {% if filename %} \u003cimg src=\"/input/{{filename}}\" width=\"500\" /\u003e {% endif %} \u003c/form\u003e 后台 flask 代码, 请求为 post 时,获得上传文件名,保存到 input 文件夹 加载 YOLOv3 模型,将图片输入,最后将输出结果保存到 output 字典中,将上传图片的名字和输出的字典传递到 image_detection.html,刷新页面 @app.route('/detection_upfile', methods=['POST']) def detection_upfile(): if request.method == 'POST': f = request.files['file'] filename = secure_filename(f.filename) output = OrderedDict() path = basedir+\"/static/input/\" file_path = path + filename f.save(file_path) print('上传成功！') print(filename) execution_path = os.getcwd() detector = ObjectDetection() detector.setModelTypeAsYOLOv3() detector.setModelPath( os.path.join(execution_path , model_path+\"yolo.h5\")) detector.loadModel() detections = detector.detectObjectsFromImage(input_image=os.path.join(execution_path , input_path+filename), output_image_path=os.path.join(execution_path , output_path+filename), minimum_percentage_probability=30) for eachObject in detections: output[eachObject[\"name\"]] = eachObject[\"percentage_probability\"] return render_template('image_detection.html',filename=filename,output=output) image_detection 拿到后台传过来的 filename 和 output,使用 Jinja模板引擎对图片进行输出并循环显示字典中的输出结果 filename 为空时不显示图,不然会有默认的 img 标签显示 output 不为空的时候循环输出字典中的 key和value {% if filename %} \u003cimg src=\"/output/{{filename}}\" width=\"500\" class=\"outputimage\"/\u003e {% endif %} \u003ctable\u003e {% if output %} {% for key, value in output.items() %} \u003ctr\u003e \u003ctd\u003e{{ key }}\u003c/td\u003e \u003ctd\u003e{{ value }}\u003c/td\u003e \u003c/tr\u003e {% endfor %} {% endif %} \u003c/table\u003e 输出样例: 退出登录 点击 sign out就会退出系统，会重定向到login.html ","date":"2021-05-13","objectID":"/posts/flask/:3:2","tags":["flask"],"title":"Flask","uri":"/posts/flask/"},{"categories":["python"],"content":"ImageAi image是一个python库，用于图像预测，对象检测，视频对象检测和视频对象跟踪 ","date":"2021-05-03","objectID":"/posts/imageai/:0:0","tags":["imageai"],"title":"ImageAi","uri":"/posts/imageai/"},{"categories":["python"],"content":"运行ImageAi ","date":"2021-05-03","objectID":"/posts/imageai/:1:0","tags":["imageai"],"title":"ImageAi","uri":"/posts/imageai/"},{"categories":["python"],"content":"winsdows所需环境 Python 3.7.6 , Download Python pip , Download pip python -m pip install --upgrade pip pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple Tensorflow 2.4.0-CPU pip install tensorflow==2.4.0 or Tensorflow-GPU if you have a NVIDIA GPU with CUDA and cuDNN installed pip install tensorflow-gpu==2.4.0 Other Dependencies pip install keras==2.4.3 numpy==1.19.3 pillow==7.0.0 scipy==1.4.1 h5py==2.10.0 matplotlib==3.3.2 opencv-python keras-resnet==0.2.0 ImageAI pip install imageai --upgrade github仓库地址 https://github.com/OlafenwaMoses/ImageAI ","date":"2021-05-03","objectID":"/posts/imageai/:1:1","tags":["imageai"],"title":"ImageAi","uri":"/posts/imageai/"},{"categories":["python"],"content":"colab环境 ImageAI !pip install imageai 下面的训练模型和训练图片也可以手动上传或关联google云盘 yolo-tiny.h5 !wget https://github.com/OlafenwaMoses/ImageAI/releases/download/1.0/yolo-tiny.h5 testImage !wget https://github.com/OlafenwaMoses/ImageAI/raw/master/data-images/image2.jpg ","date":"2021-05-03","objectID":"/posts/imageai/:1:2","tags":["imageai"],"title":"ImageAi","uri":"/posts/imageai/"},{"categories":["python"],"content":"运行 vscode中运行,确保有Python扩展和TabNine扩展,并且选择了Python3.7解释器 没选的control+shift+p然后输入Python找到Select Interpreter回车勾选Python3.7解释器后回车 新建一个文件夹imageai 鼠标右键git bash here执行 git init git clone https://github.com/OlafenwaMoses/ImageAI.git 新建一个文件夹test,鼠标右键用vscode打开 图像预测 图像预测可以预测图片中的内容，目前支持4种算法用来进行图像预测MobileNetV2, ResNet50, InceptionV3 and DenseNet121, 下载训练模型移到test这个文件夹 Download ResNet50 Model 从仓库文件夹imageai中选取训练图片移到test文件夹 新建firstPrediction.py文件,copy以下代码 from imageai.Prediction import ImagePrediction import os # 获得当前路径 execution_path = os.getcwd() prediction = ImagePrediction() # 加载AsResNet50模型 prediction.setModelTypeAsResNet50() prediction.setModelPath(os.path.join(execution_path, \"resnet50_imagenet_tf.2.0.h5\")) # 加载模型 prediction.loadModel() # 返回预测结果 predictions, probabilities = prediction.predictImage(os.path.join(execution_path, \"12.jpg\"), result_count=5) for eachPrediction, eachProbability in zip(predictions, probabilities): print(eachPrediction , \" : \" , eachProbability) print(\"--------------------------------\") vscode控制台 执行 python firstPrediction.py 图片 训练结果 mountain_bike : 59.61750149726868 -------------------------------- bicycle-built-for-two : 20.329207181930542 -------------------------------- jinrikisha : 6.335373967885971 -------------------------------- crash_helmet : 1.6147501766681671 -------------------------------- tricycle : 0.8636814542114735 -------------------------------- 可以看到识别出了最主要的山地自行车和两个骑自行车的人，但还识别出了三个概率比较小的黄包车,安全帽,三轮车 目标检测 目标预测可以框出图片中的目标，并识别出来，目前支持RetinaNet, YOLOv3 and TinyYOLOv3三种深度学习算法 下载模型文件移入test文件夹 YOLOv3 Model - yolo.h5 从仓库文件夹imageai选取训练图片移入test文件夹 新建firstDetection.py文件 copy以下代码 from imageai.Detection import ObjectDetection import os execution_path = os.getcwd() detector = ObjectDetection() detector.setModelTypeAsYOLOv3() detector.setModelPath( os.path.join(execution_path , \"yolo.h5\")) detector.loadModel() detections = detector.detectObjectsFromImage(input_image=os.path.join(execution_path , \"10.jpg\"), output_image_path=os.path.join(execution_path , \"New11.jpg\"), minimum_percentage_probability=30) for eachObject in detections: print(eachObject[\"name\"] , \" : \", eachObject[\"percentage_probability\"], \" : \", eachObject[\"box_points\"] ) print(\"--------------------------------\") vscode控制台 执行 python firstDetection.py 图片 训练结果 dog : 98.87264966964722 : [116, 103, 311, 373] -------------------------------- dog : 99.15174841880798 : [338, 69, 488, 409] -------------------------------- dog : 98.93686175346375 : [503, 154, 638, 386] -------------------------------- 在目标检测源代码的基础上,增加一个参数就可以将识别出来的对象从原图分割出来保存到新的文件夹，增加的代码在这一行 的extract_detected_objects=True detections, objects_path = detector.detectObjectsFromImage(input_image=os.path.join(execution_path , \"10.jpg\"), output_image_path=os.path.join(execution_path , \"new10.jpg\"), minimum_percentage_probability=30, extract_detected_objects=True) 重新运行的结果: 视频检测 ImageAI可以提供方便的视频检测跟踪和视频分析功能,目前支持三种深度学习算法RetinaNet,YOLOv3,TinyYOLOv3 下载模型文件移入test文件夹 TinyYOLOv3 Model - yolo-tiny.h5 从仓库文件夹imageai选取训练视频traffic.mp4移入test文件夹 新建firstVedioDetection.py文件 copy以下代码 from imageai.Detection import VideoObjectDetection import os execution_path = os.getcwd() detector = VideoObjectDetection() detector.setModelTypeAsTinyYOLOv3() detector.setModelPath( os.path.join(execution_path , \"yolo-tiny.h5\")) detector.loadModel() # frames_per_second保存的视频每秒帧数,视频检测秒数 video_path = detector.detectObjectsFromVideo(input_file_path=os.path.join(execution_path, \"traffic.mp4\"), output_file_path=os.path.join(execution_path, \"traffic_detected_all\") , frames_per_second=20, log_progress=True,detection_timeout=2) 这里的视频检测代码是输出2s的视频,每秒20帧,因为使用电脑的cpu跑的,如果你安装好了cuda和cuDNN和GPU版本的Tensorflow库你可以设置更多的输出时长和视频帧率 以下是在colab用CPU跑的每秒30帧的10s输出视频结果,一共用将近20分钟,设置参数时可以做个参考 执行代码: python firstVidioDetection.py 原视频片段: 识别后: 修改代码,只识别摩托车自行车和人 from imageai.Detection import VideoObjectDetection import os execution_path = os.getcwd() detector = VideoObjectDetection() detector.setModelTypeAsTinyYOLOv3() detector.setModelPath( os.path.join(execution_path , \"yolo-tiny.","date":"2021-05-03","objectID":"/posts/imageai/:1:3","tags":["imageai"],"title":"ImageAi","uri":"/posts/imageai/"},{"categories":["python"],"content":"运行原理 这里的图像预测用到了ResNet50算法,目标检测用到了YOLOv3算法,视频检测用到了TinyYOLOv3算法,下面分别将它们的实现原理 ","date":"2021-05-03","objectID":"/posts/imageai/:2:0","tags":["imageai"],"title":"ImageAi","uri":"/posts/imageai/"},{"categories":["python"],"content":"ResNet 传统深度学习面临的问题 神经网络层次越深，学习效果不一定越好，当模型层数增加到某种程度的时候，模型的效果会不升反降，深度模型发生退化情况,发生这种情况有以下几点原因： 过拟合 模型层数过多,训练模型过于复杂,训练样本少,就会过分去拟合了训练集，放大了差异性，衰弱了共性,导致过拟合 梯度消失和爆炸 梯度的本意是一个向量（矢量），表示某一函数在该点处的方向导数沿着该方向取得最大值，即函数在该点处沿着该方向（此梯度的方向）变化最快，变化率最大（为该梯度的模） 反向传播（英语：Backpropagation，缩写为BP）该方法计算对网络中所有权重计算损失函数的梯度。这个梯度会反馈给最优化方法，用来更新权值以最小化损失函数。 在神经网络上执行梯度下降法的主要算法。该算法会先按前向传播方式计算（并缓存）每个节点的输出值，然后再按反向传播遍历图的方式计算损失函数值相对于每个参数的偏导数。 假设我们现在需要计算一个函数$f(x,y,z)=(x+y)*z$ 在$x=-2,y=5,z=-4$的梯度,计算流程如下: 向前传播计算: $f(x=2,y=5,z=-4)$结果为-12 反向传播计算: 令$q=x+y$ ${\\frac {df}{dz}}=q=x+y=3$ ${\\frac {df}{dx}}={\\frac {df}{dq}}\\cdot{\\frac {dq}{dx}}=z\\cdot1=-4$ ${\\frac {df}{dy}}={\\frac {df}{dq}}\\cdot{\\frac {dq}{dx}}=z\\cdot1=-4$ 这里假设输出端初始的梯度为 1，也就是输出端对自身求导等于 1。当神经网络反向传播的时候，不难发现，在输出端梯度的模值，经过回传扩大了3或缩小4倍 这是由于反向传播结果的数值大小不止取决于求导的式子，很大程度上也取决于输入的模值 那么当每次输入的模值都大于1时，训练10000次，每次扩大3倍，这个梯度会变成$3^{10000}$,会发生梯度爆炸 那么当每次输入的模值都小于1时，训练10000次，每次缩小4倍，这个梯度会变成$4^{-10000}$,会发生梯度消失 ResNet的提出(残差网络) 如果深层网络后面的层都是恒等映射,那么模型就可以转换为一个浅层网络,问题是如何得到恒等映射? 恒等映射需要 $H(x)=x$,但是实现非常困难,因此残差网络是将网络设计为$H(x)=F(x)+x$,这样就把问题转化为学习一个残差函数$F(x)=H(x)-x$ 只要我们$F(x)=0$,就构成了恒等映射 $H(x)=x$,于是就有了Residual block结构 在上图的残差网络结构图中，通过shortcut connections（捷径连接）的方式，直接把输入$x$ 传到输出作为初始结果，输出结果为 $H(x)=F(x)+x$ ，当$F(x)=0$ 时，那么 $H(x)=x$ ，也就是上面所提到的恒等映射。于是，ResNet相当于将学习目标改变了，不再是学习一个完整的输出，而是目标值 $H(X) 和 x$ 的差值，也就是所谓的残差 $F(x):= H(x)-x$ ，因此，后面的训练目标就是要将残差结果逼近于0，使到随着网络加深，准确率不下降。 这种残差跳跃式的结构，打破了传统的神经网络n-1层的输出只能给n层作为输入的惯例，使某一层的输出可以直接跨过几层作为后面某一层的输入，其意义在于为叠加多层网络而使得整个学习模型的错误率不降反升的难题提供了新的方向 至此，神经网络的层数可以超越之前的约束，达到几十层、上百层甚至千层，为高级语义特征提取和分类提供了可行性 在2015年的ImageNet图像识别大赛中，作者何恺明和他的团队用“图像识别深度差残学习”系统，击败谷歌、英特尔、高通等业界团队，荣获第一 ResNet图像预测 卷积(convolution),彩色图片转化为RGB三个通道的矩阵,对每个矩阵进行卷积然后合并输出,提取图像的特征 池化（Pooling），有的地方也称汇聚，实际是一个下采样（Down-sample）过程。由于输入的图片尺寸可能比较大，这时候，我们需要下采样，减小图片尺寸 全连接层把卷积层和池化层的输出展开成一维形式，在后面接上与普通网络结构相同的回归网络或者分类网络,一般接在池化层后面，这一层的输出即为我们神经网络运行的结果 ","date":"2021-05-03","objectID":"/posts/imageai/:2:1","tags":["imageai"],"title":"ImageAi","uri":"/posts/imageai/"},{"categories":["python"],"content":"YOLOv3 YOLOv3目标检测分为两步： 确定检测对象的位置 对检测对象进行分类，识别出图像的内容，定位识别出的目标的位置，框出，框出目标需要4个参数：中心点的横纵坐标，框的宽和高 ","date":"2021-05-03","objectID":"/posts/imageai/:2:2","tags":["imageai"],"title":"ImageAi","uri":"/posts/imageai/"},{"categories":["python"],"content":"大致流程 图片进入YOLOv3网络,图片首先会被调整到 416*416 的大小,输入Darknet53进行图像的特征提取,为了防止失真会在图片边缘加上灰条,之后图片会分成三个网格图片（13×13，26×26，52×52） 网格中每个网格点都有3个先验框,通过调参来穷举,试探框内是否有目标,有目标就框选出来 13x13的特征层会进行5次卷积,会有两个方向的输出,一个输出会向上采样和26x26的特征层进行结合,另一个输出会进行3x3的卷积和1x1的卷积,之后进行通道调整,调整完的结果就是一个特征层的预测结果: (batch_size,13,13,75) 13x13的网格有169个网格点 75 可以分解为 3x25 3表示每个网格点有3个先验框 其中25包含了 4+1+20, 分别代表4: x_offset, y_offset, height和width, 1:置信度, 20:分类结果 13x13的特征层向上采样的输出会和 26x26 的特征层进行结合, 结合之后再进行5次卷积进行特征提取,会有两个方向的输出,一个输出会向上采样和52x52的特征层进行结合,另一个输出会进行3x3的卷积和1x1的卷积,之后进行通道调整,调整完的结果就是一个特征层的预测结果: (batch_size,26,26,75),类似13x13 之后是 26x26向上采样的输出会和 52x52 的特征层进行结合, 结合之后再进行5次卷积进行特征提取,最后进行进行3x3的卷积和1x1的卷积,之后进行通道调整,调整完的结果就是一个特征层的预测结果: (batch_size,52,52,75),类似13x13 ","date":"2021-05-03","objectID":"/posts/imageai/:2:3","tags":["imageai"],"title":"ImageAi","uri":"/posts/imageai/"},{"categories":["windows"],"content":"FFmpeg FFmpeg是一套可以用来记录转换数字音频,视频，并能将其转换为流的开源计算机程序 ","date":"2021-04-26","objectID":"/posts/ffmpeg/:0:0","tags":["ffmpeg"],"title":"FFmpeg安装使用","uri":"/posts/ffmpeg/"},{"categories":["windows"],"content":"安装 从github仓库下载FFmpeg 解压后将bin目录加载到系统path路径 win+r输入sysdm.cpl,进入高级-\u003e环境变量 cmd查看是否安装好了,和图中一样就是安装好了 ","date":"2021-04-26","objectID":"/posts/ffmpeg/:1:0","tags":["ffmpeg"],"title":"FFmpeg安装使用","uri":"/posts/ffmpeg/"},{"categories":["windows"],"content":"使用 ","date":"2021-04-26","objectID":"/posts/ffmpeg/:2:0","tags":["ffmpeg"],"title":"FFmpeg安装使用","uri":"/posts/ffmpeg/"},{"categories":["windows"],"content":"视频提取音频 这里介绍视频提取音频的使用,在存放demo.flv视频的文件夹进入cmd执行下列命令 视频最好更改为英文名 ffmpeg -i demo.flv -f mp3 -vn demo.mp3 ","date":"2021-04-26","objectID":"/posts/ffmpeg/:2:1","tags":["ffmpeg"],"title":"FFmpeg安装使用","uri":"/posts/ffmpeg/"},{"categories":["windows"],"content":"合并多个视频 先创建一个文本文件，包含需要拼接的文件的列表，此文档和3个视频同一目录下 filelist.txt file ‘input1.pm4’ file ‘input2.pm4’ file ‘input3.pm4’ 在目录下进入cmd执行以下命令行 ffmpeg -f concat -i filelist.txt -c copy output.mp4 ","date":"2021-04-26","objectID":"/posts/ffmpeg/:2:2","tags":["ffmpeg"],"title":"FFmpeg安装使用","uri":"/posts/ffmpeg/"},{"categories":["windows"],"content":"按照时间切割音频/视频 切割音频 在存放input.mp3文件的目录下进入cmd执行以下命令行 ffmpeg -i input.mp3 -ss 00:03:10 -to 00:05:10 output.mp3 切割视频 在存放input.mp4文件的目录下进入cmd执行以下命令行 ffmpeg -i input.mp4 -ss 00:03:10 -to 00:05:10 -c copy output.mp4 ","date":"2021-04-26","objectID":"/posts/ffmpeg/:2:3","tags":["ffmpeg"],"title":"FFmpeg安装使用","uri":"/posts/ffmpeg/"},{"categories":["windows"],"content":"视频转GIF 将视频中的一部分转换为GIF,从视频中第3秒开始截取时长为3秒的片段转化为 gif ffmpeg -t 3 -ss 00:00:03 -i test.mp4 test-clip.gif 转化高质量 GIF ffmpeg -i test.mp4 -b 2048k test.gif 将 GIF 转换为 MP4 ffmpeg -f gif -i test.gif test.mp4 移除视频中的音频(静音),-an 就是禁止音频输出 ffmpeg -i input.mov -an mute-output.mov ","date":"2021-04-26","objectID":"/posts/ffmpeg/:2:4","tags":["ffmpeg"],"title":"FFmpeg安装使用","uri":"/posts/ffmpeg/"},{"categories":["English grammar"],"content":"英语从句 英语的所有句子都由简单句组成，除单独的简单句外，还能将简单句进行两种组合 并列关系组合（Compound Sentence） 主从关系组合（Complex Sentence） 在主，谓，宾，表，定，状，补，同位语中，除谓语外其他句子成分都可以用简单句构成从句 按照从句的充当的成分可以划分为，名词性从句，形容词从句，副词从句 ","date":"2021-04-23","objectID":"/posts/subordinate/:0:0","tags":["English"],"title":"英语从句","uri":"/posts/subordinate/"},{"categories":["English grammar"],"content":"名词性从句 名词性从句就是用从句充当名词可以充当的成分，一共包括5类 主语从句 宾语从句 表语从句 宾语补语从句 同位语从句 ","date":"2021-04-23","objectID":"/posts/subordinate/:1:0","tags":["English"],"title":"英语从句","uri":"/posts/subordinate/"},{"categories":["English grammar"],"content":"名词性从句的引导词 根据从句在句子中所作的成分，一共可以分为三类引导词 that,从句是陈述句时 that引导的名词性从句需要注意 that在从句中不充当成分，也没有实义 在不影响句子意思的情况下可以省略，但是引导主语从句位于句首不省略 引导同位语从句一般不省略 2. whether/if,从句是一般疑问句时 需要注意的点 whether/if,在从句中不充当成分，意思为是否 whether可以引导所有的名词性从句 if只能引导宾语从句,否定结构宾语从句不用whether 3.特殊疑问词,当从句是特殊疑问句时,常见的连接副词有:when,where,why,how,常见的连接代词有:who,whom,what,which,whose ","date":"2021-04-23","objectID":"/posts/subordinate/:1:1","tags":["English"],"title":"英语从句","uri":"/posts/subordinate/"},{"categories":["English grammar"],"content":"名词性从句分析步骤 先找出句子的谓语动词，后根据从句在句中的位置来判断它属于哪一种名词性从句 先成分后含义——先分析连接词在从句中的成分，后根据含义直接翻译即可 若作主、宾、表、定语等成分，则用what(ever), who(ever), whom(ever), whose, which(ever)引导 若不作成分，则用that, if, whether引导，只起连接作用 从句是特殊疑问句，则用how,when(ever), where(ever), why引导。 注意:主语从句常放在主句谓语动词之前，it作形式主语除外；表语从句位于系动词后；宾语从句位于动词或介词后；同位语从句位于名词之后，但要注意区分定语从句和同位语从句 ","date":"2021-04-23","objectID":"/posts/subordinate/:1:2","tags":["English"],"title":"英语从句","uri":"/posts/subordinate/"},{"categories":["English grammar"],"content":"名词性从句分类 主语从句 简单句充当主语,通常是引导词加从句构成主语从句 引导词+从句+主句 去除掉引导词句子词序和中文一致 形式主语 That the rabbit ate a carrot is obvious. 这样的主语从句头重脚轻，因此建议修改成it作形式主语的形式 It is obvious that the rabbit ate a carrot. 这样的主谓结构一般主要意思放在前面,下面是一些常见it句子结构 It is + adj./n. + to do sth. It is + v. + to do sth. It is + adj./n. + doing sth. It + be + adj./n. + that 从句 It + be + 动词过去分词 + that从句 that的省略 that引导的主语从句位于句首,that就不能省略 使用it作形式主语,that从句位于句末,that可以省略 省略不省略that,前提是保持句子意思完整 宾语从句 简单句作宾语,一般包含确定信息和不确定信息 只有that引导词可以省略,但是省略的时候不能引起句子歧义 否定加在谓语动词前,而不是从句中 大多数情况下主从时态一致,但是客观永恒表达除外 I knew (that) the sun rises in the east. 表语从句 用从句替代表语,表语是通过连系动词将动词前后划等号,前面是主语后面是主语补语(表语) 表语从句就是将主语从句移到系动词后面 That the rabbit ate a carrot is a secert. The secert is that the rabbit ate a carrot. 同位语从句 简单句作同位语,用不同的方式将一个概念再说一遍,用从句修饰解释抽象名词 宾语补语从句 简单句作宾语补语 ","date":"2021-04-23","objectID":"/posts/subordinate/:1:3","tags":["English"],"title":"英语从句","uri":"/posts/subordinate/"},{"categories":["English grammar"],"content":"定语从句 简单句作定语修饰先行词,定语是对前面名词的范围缩小精确化,分前置定语和后置定语,定语从句分为 限制性定语从句:限定名词范围 非限制性定语从句:不限定名词范围,补充说明,可去掉,可以代前面整个句子 区别 区分点 限制性定语从句 非限制性定语从句 与先行词的关系 关系紧密,删除后影响句子意思 关系疏松,其补充说明作用,删除后不影响主句意思 逗号的作用 不用逗号 用逗号 that的作用 可以用that 不可用that which/whom在从句中作宾语的省略 可省略 可以 是否可以修饰句子 不可以 可以 翻译时的区别 常翻译为定语 常翻译为两个独立的句子 关系词分为 关系代词: that,who,whom,whose,which 关系副词:where,why,when that/which一般可互换,但是 先行词唯一:that,代一个名词 先行词多选一:which,代多个名词中一个 关系副词 = 介词 + which ","date":"2021-04-23","objectID":"/posts/subordinate/:2:0","tags":["English"],"title":"英语从句","uri":"/posts/subordinate/"},{"categories":["English grammar"],"content":"状语从句 在句子中起副词作用,一般补充说明动词,形容词,副词等.根据引导词一共可以分为9类:时间,地点,条件,让步,方式,比较,原因,目的,结果 ","date":"2021-04-23","objectID":"/posts/subordinate/:3:0","tags":["English"],"title":"英语从句","uri":"/posts/subordinate/"},{"categories":["English grammar"],"content":"时间状语从句 引导词: 普通引导词: when(在…时候) as(正当/随着) while(在…期间) once(一旦) as soon as(一…就…) before(在…之前) after(在…之后) since(自…以来) not…until(直到…才) until/till(直到…时) 名词短语 the moment(一…就) every time(每当) the day(那一天) the instant (当…的时候) 副词 immediately,directly,no sooner…than,hardly…when,scarcrly…when 都表示一…就 when,while,as的区别 when表\"当…时\",引导的从句谓语动词可以用延续性动词,也可以用短暂性动词,强调时间点 while表\"在…时\",引导的从句谓语动词只能用延续性动词,强调时间段 as表\"一边…一边…\",引导的从句谓语动词是延续性动词,强调同时发生 no sooner…than和hardly…when引导的时间状语从句 含义 : 表一…就… 时态: 主句用过去完成时,从句用一般过去时 when特殊用法 当when引导时间状语从句,如果从句和主句主语一致,并且从句的谓语中有be动词,此时从句的主语和be动词可以一起省略 When I was a little boy, I loved phenbi so much. 省略后 When a little boy, I loved phenbi so much. 区分until和not…until 主句的谓语动词是短暂性动词,用not…until,如果是延续性动词,使用until ","date":"2021-04-23","objectID":"/posts/subordinate/:3:1","tags":["English"],"title":"英语从句","uri":"/posts/subordinate/"},{"categories":["English grammar"],"content":"地点状语从句 常用引导词: where 强调形式引导词: wherever, everywhere, anywhere where引导的地点状语从句和定语从句的区别与转换 区别 where指代前面的先行词就是定语从句,否则就是地点状语从句 当where引导地点状语从句时,where是从属连词,从句修饰主句的谓语动词,where前边没有表示地点的先行词 转换 一般在状语从句前加上\"in/at the + 具体地点\",就变成了定语从句 ","date":"2021-04-23","objectID":"/posts/subordinate/:3:2","tags":["English"],"title":"英语从句","uri":"/posts/subordinate/"},{"categories":["English grammar"],"content":"比较状语从句 常用引导词: as, than 特殊引导词: the more…the more…,more than, more…than…,not so mush … as… ","date":"2021-04-23","objectID":"/posts/subordinate/:3:3","tags":["English"],"title":"英语从句","uri":"/posts/subordinate/"},{"categories":["English grammar"],"content":"条件状语从句 常用引导词: if, unless(表示 if not) 特殊引导词: as/so long(只要), only if(只要), providing/provided that(假如), supposing(that)(假如), in case that(以防), on condition that(如果) 一般条件句比主句落后一个时间段 ","date":"2021-04-23","objectID":"/posts/subordinate/:3:4","tags":["English"],"title":"英语从句","uri":"/posts/subordinate/"},{"categories":["English grammar"],"content":"让步状语从句 让步状语从句是用来阐述相反/相对的某种情况 常用引导词: though, although, even if, even though 特殊引导词: as, while(作\"虽然\"之意讲,用在句首), no matter…(无论), in spite of the fact that(虽然,尽管), whatever, whoever, wherever, whenever, however, whichever 假设的情况 Even if i see an egg, I will not eat it. 事实的情况 Although I see a carrot, I will not eat it. ","date":"2021-04-23","objectID":"/posts/subordinate/:3:5","tags":["English"],"title":"英语从句","uri":"/posts/subordinate/"},{"categories":["English grammar"],"content":"方式状语从句 条件,让步,方式状语从句都是阐述某种情况/做出某种假设 常用引导词: as, as if, as though(好像,似乎) 特殊引导词: the way(方式) 一般分为两种形式 好像某事发生过的方式 I feel good as if I just ate an egg. 好像某事正在发生的方式 Leave the egg as it is. ","date":"2021-04-23","objectID":"/posts/subordinate/:3:6","tags":["English"],"title":"英语从句","uri":"/posts/subordinate/"},{"categories":["English grammar"],"content":"原因状语从句 原因,目的,结果状语从句–\u003e表达了某种因果 如 A–\u003eB的形式 常用引导词: because, since, as , for 不常用引导词: seeing that, now that, in that, considering that, given that, as much as, so much as 这些介词短语也翻译成因为,但是后面只能跟名词(短语) because of, due to , owing to, thanks to, for the sake of, as a result of ","date":"2021-04-23","objectID":"/posts/subordinate/:3:7","tags":["English"],"title":"英语从句","uri":"/posts/subordinate/"},{"categories":["English grammar"],"content":"目的状语从句 常用引导词: so that, in order that 常用动词不定式: to , in order to, so as to,后跟动词原形 用 in order to的时候一定要保持前后主语一致,主语不一致的时候要使用 in order that ","date":"2021-04-23","objectID":"/posts/subordinate/:3:8","tags":["English"],"title":"英语从句","uri":"/posts/subordinate/"},{"categories":["English grammar"],"content":"结果状语从句 常用引导词: so that, so…that, such…that 不常用引导词: to the degree that, to the extent that, to such a degree that so that，so…that和such…that的区别 so that既可以引导目的状语从句,也可以引导结果状语从句,引导目的状语时,会和情态动词一起连用,引导结果状语从句时,则不和情态动词连用 so…that的用法 so + adj./adv. + that so + many/much/few/little + n. +that so + adj. + a/an + 可数名词单数 +that such…that的用法 such + a/an + adj. + 可数名词单数 + that such + adj + 可数名词复数/不可数名词 + that ","date":"2021-04-23","objectID":"/posts/subordinate/:3:9","tags":["English"],"title":"英语从句","uri":"/posts/subordinate/"},{"categories":["database"],"content":"数据库的ACID原则 ","date":"2021-04-21","objectID":"/posts/acid/:0:0","tags":["ACID"],"title":"ACID","uri":"/posts/acid/"},{"categories":["database"],"content":"事务 事务是一系列对系统中数据进行访问或更新的操作所组成的一个程序执行逻辑单元(Unit).为应用层服务的,而不是数据库系统本身的需要,事务用来确保不论发生任何情况,数据始终处于一个合理的状态 事务一般分为三个状态,Active,Commit,Failed 完整的事务进一步放大看，事物内部还有部分提交这个中间状态，其对外是不可见的 ","date":"2021-04-21","objectID":"/posts/acid/:1:0","tags":["ACID"],"title":"ACID","uri":"/posts/acid/"},{"categories":["database"],"content":"A(Atomicity)原子性 原子性,是指全有或者全无原则,事务的所有操作要么全部提交成功,要么全部失败回滚,不可能出现部分失败的情况,因为事务在执行的时候出问题,数据的错误是未知的,将它回滚到执行前的状态便于进行处理 比如A转账给B ,这里A的账户余额要减少,B的账户余额要增加,增加和减少的操作要么都成功,要么都失败,不可能出现成功一个失败一个的情况 刚说的是操作,为什么呢?因为这里如果是A转账给B 500元,A账户减少 500元,B账户增加300元,这是符合原子性的!但是A减少的金额和B增加的金额并不相等,逻辑上有错误 为此数据库提供另一个原则一致性解决这个问题 ","date":"2021-04-21","objectID":"/posts/acid/:2:0","tags":["ACID"],"title":"ACID","uri":"/posts/acid/"},{"categories":["database"],"content":"B(Consistency)一致性 一致性,是指事务在提交和回滚的变换过程中,数据保持一致性和正确性. 回到刚刚的问题 A转账给B 500元,A账户减少 500元,B账户增加300元,符合原子性! 一致性不允许数据不一致,因此出现这种情况会回滚到转账前的状态 但是又会有这样的情况 A和C同时向B转账100元,B账户原有余额为300元,事务执行之后B的账户应该有500元,但是A和C的事务同时读取B的账户余额,都执行+100,然后都得到400,都写入400,最后B的账户余额是400元 这一过程中,原子性符合,一致性也符合,但是数据还是错误,对此我们还需要另一个特性隔离性来约束它 ","date":"2021-04-21","objectID":"/posts/acid/:3:0","tags":["ACID"],"title":"ACID","uri":"/posts/acid/"},{"categories":["database"],"content":"C(Isolation)隔离性 隔离性,一个事务所做的修改在最终提交前,对其他事务是不可见的.可以理解为在排队,前一个事务没有执行完,下一个事务不能操作前一个事务操作的数据. 对于刚刚的问题虽然A和B同时是转账的,但是隔离性会在A转账成功之后再允许C转账,这样数据就不会得到400,而是500 满足原子性,一致性,隔离性,数据基本在事务执行前后可以保持一致正确,可要是在事务执行的过程中数据库突然崩溃,服务器突然断电,存储的数据会不会发生改变?这里引入最后一个特性持久性 ","date":"2021-04-21","objectID":"/posts/acid/:4:0","tags":["ACID"],"title":"ACID","uri":"/posts/acid/"},{"categories":["database"],"content":"D(Durability)持久性 持久性,事务一旦提交,所做的修改就是永久性的.即使发生系统崩溃或者机器宕机等故障,只要数据库可以重新启动,就可以根据事务日志对未持久化的数据进行重新操作 许多数据库通过引入预写式日志（Write-ahead logging，缩写 WAL）机制，来保证事务持久性和数据完整性，同时又很大程度上避免了基于事务直接刷新数据的频繁IO对性能的影响。 在使用WAL的系统中，所有的修改都先被写入到日志中，然后再被应用到系统状态中。假设一个程序在执行某些操作的过程中机器掉电了。在重新启动时，程序可能需要知道当时执行的操作是成功了还是部分成功或者是失败了。如果使用了WAL，程序就可以检查log文件，并对突然掉电时计划执行的操作内容跟实际上执行的操作内容进行比较。在这个比较的基础上，程序就可以决定是撤销已做的操作还是继续完成已做的操作，或者是保持原样。 ","date":"2021-04-21","objectID":"/posts/acid/:5:0","tags":["ACID"],"title":"ACID","uri":"/posts/acid/"},{"categories":["database"],"content":"总结 ","date":"2021-04-21","objectID":"/posts/acid/:6:0","tags":["ACID"],"title":"ACID","uri":"/posts/acid/"},{"categories":["windows"],"content":"常用软件 Chrome Bandizip,防火墙设置拦截更新程序,U盘安装 7zip Snipaste githubClash,设置自动更新订阅 蓝奏云Clash mixin开启增强模式 mixin:dns:enable:truelisten:127.0.0.1:53default-nameserver:- 223.5.5.5- 1.0.0.1ipv6:falseenhanced-mode:fake-ip#redir-hostnameserver:- tls://223.5.5.5:853- https://dns.pub/dns-query- https://dns.alidns.com/dns-queryfallback:#if https-dns not working,try (DOT)tls://- https://1.0.0.1/dns-query #tls://1.0.0.1:853- https://public.dns.iij.jp/dns-query- https://dns.google/dns-query#tls://8.8.4.4:853fallback-filter:geoip:trueipcidr:- 240.0.0.0/4- 0.0.0.0/32- 127.0.0.1/32domain:- +.google.com- +.facebook.com- +.youtube.com- +.xn--ngstr-lra8j.com- +.google.cn- +.googleapis.cn Potplayer 无边框设置 腾讯桌面管理软件 Coodesker OBS Gif动图录制软件 uTools 内部安装everything XMind ZEN u盘安装 百度网盘 IDM 绿色版IDM 手动破解版IDM Motrix dht.bat YAAMconfig Motrix-extension Typora Obsidian Obsidian Nord主题 Notion picgo Capslock+ IObit Uninstaller Portable BookxNote pro vscode Nord Operator Theme c:/user/.vscode下更改theme.json文件fontstyle为“”，去除斜体样式 sublimeText3 idea git Vmware workstation U盘安装 Termius U盘安装 ","date":"2021-04-19","objectID":"/posts/software/:1:0","tags":["windows"],"title":"Software","uri":"/posts/software/"},{"categories":["windows"],"content":"开发环境 go java jdk1.8 c/c++ MinGW/Clang python3 you-get you-get -x 127.0.0.1:7890 \" \" scoop 包管理工具 scoop config proxy 127.0.0.1:7890 annie scoop install annie git MySQL Redis node npm hugo Fira Code字体 字体配置 \"editor.fontFamily\": \"Fira Code\", \"editor.fontLigatures\": false, //不开启连字 \"editor.fontSize\": 15, \"editor.fontWeight\": \"normal\", Noto Serif字体 Mactype cmd设置代理 set http_proxy=http://127.0.0.1:7890 set https_proxy=http://127.0.0.1:7890 ","date":"2021-04-19","objectID":"/posts/software/:2:0","tags":["windows"],"title":"Software","uri":"/posts/software/"},{"categories":["windows"],"content":"网络问题 谷歌浏览器无法上网时的3种解决方案 1.更改dns为阿里的223.5.5.5 2.cmd执行以下命令 netsh winsock reset :: 重置winsock目录 netsh int ip reset :: 重置tcp/ip各组件到初始状态 ipconfig /release :: DHCP客户端手工释放动态IP地址 ipconfig /renew :: DHCP客户端手工向服务器刷新请求 ipconfig /flushdns :: 清除本地DNS缓存 3.设置–\u003e网络和Internet–\u003e状态–\u003e网络重置 谷歌浏览器重定向到www.google.com.hk 的解决方案 安装浏览器扩展URLRedirector 添加用户规则 或者在广告拦截插件uBlock Origin中加入 ||google.com.hk$script ","date":"2021-04-19","objectID":"/posts/software/:3:0","tags":["windows"],"title":"Software","uri":"/posts/software/"},{"categories":["English grammar"],"content":"引言\r\r首先我们需要知道,所有的英语语法都是为了造句.而且英语和中文一样,有结构简单的句子也有结构复杂的句子,那么我们到底怎么学语法?\r\r 其实所有的长句子都是由简单句构成,所以我们从简单句开始学习语法,而这些简单句除开一些感叹句省略句,以及整句都是提问的句子,都是在说 什么 怎么样 这里的 什么 和 怎么样对应了两个最基本的句子成分 主语 和 谓语 这里的主语一般是人或物. 这里的谓语对应了一个广义的动作/发生了什么事,实际上就是我们所说的语法上的 动词 ","date":"2021-04-17","objectID":"/posts/english/:0:0","tags":["English"],"title":"英语语法框架","uri":"/posts/english/"},{"categories":["English grammar"],"content":"谓语动词的分类 这里给出一张谓语动词分类的思维导图 谓语动词的分类对应了五种最基本的句型 主谓 主谓宾 主谓双宾 主谓宾宾补 主谓表 所有的复杂句都是由这五种句型组合成的 ","date":"2021-04-17","objectID":"/posts/english/:1:0","tags":["English"],"title":"英语语法框架","uri":"/posts/english/"},{"categories":["English grammar"],"content":"句子成分 句子成分不仅仅只有五种句型中的,还有其他的句子成分,这里对所有的句子成分逐个解释 ","date":"2021-04-17","objectID":"/posts/english/:2:0","tags":["English"],"title":"英语语法框架","uri":"/posts/english/"},{"categories":["English grammar"],"content":"主语 动作的发出者 能作主语的有代词,名词(短语)和非谓语结构,从句 主语缺失时的三个解决方案 it做形式主语 There be 被动语态 ","date":"2021-04-17","objectID":"/posts/english/:2:1","tags":["English"],"title":"英语语法框架","uri":"/posts/english/"},{"categories":["English grammar"],"content":"谓语动词 发生的动作/发生的事,谓语是具有时态和语态的实义动词(词组)或系动词 包含情态动词的谓语先排除,主语不能发出动作需要使用被动语态 ","date":"2021-04-17","objectID":"/posts/english/:2:2","tags":["English"],"title":"英语语法框架","uri":"/posts/english/"},{"categories":["English grammar"],"content":"宾语 动作的承受者 能作宾语的成分主语完全一样:代词,名词(短语)和非谓语结构,从句 常用动宾,介宾搭配 ","date":"2021-04-17","objectID":"/posts/english/:2:3","tags":["English"],"title":"英语语法框架","uri":"/posts/english/"},{"categories":["English grammar"],"content":"表语 主语补足语,对主语进行补充 能作表语的成分代词,名词(短语),非谓语结构,从句形容词短语和介词短语 ","date":"2021-04-17","objectID":"/posts/english/:2:4","tags":["English"],"title":"英语语法框架","uri":"/posts/english/"},{"categories":["English grammar"],"content":"定语 主要用来修饰主语或宾语,缩小要修饰部分的范围 能作定语的有 名词(短语),形容词(短语) 介词短语 分词,不定式 从句 定语分前置和后置 前置:形容词放在所修饰的名词或代词的前面 后置:对名词进行范围缩小和精确化 ","date":"2021-04-17","objectID":"/posts/english/:2:5","tags":["English"],"title":"英语语法框架","uri":"/posts/english/"},{"categories":["English grammar"],"content":"状语 主要用来修饰谓语动词,说明时间,地点,条件,程度等. 能作状语的有形容词(短语),副词(短语) 介词短语 分词,不定式 从句 ","date":"2021-04-17","objectID":"/posts/english/:2:6","tags":["English"],"title":"英语语法框架","uri":"/posts/english/"},{"categories":["English grammar"],"content":"补语 修饰主语或者宾语 ","date":"2021-04-17","objectID":"/posts/english/:2:7","tags":["English"],"title":"英语语法框架","uri":"/posts/english/"},{"categories":["English grammar"],"content":"同位语 把主语或者宾语再说一遍 ","date":"2021-04-17","objectID":"/posts/english/:2:8","tags":["English"],"title":"英语语法框架","uri":"/posts/english/"},{"categories":["English grammar"],"content":"独立成分 当一个词、短语或从句用在句子里面，与句子的其他成分只有意义上的联系而没有语法关系时，它就称为独立成分。常见的独立成份有呼吁、感叹语、答语、插入语、介词短语、非谓语动词所构成的短语及形容词、副词所引起的词组等 ","date":"2021-04-17","objectID":"/posts/english/:2:9","tags":["English"],"title":"英语语法框架","uri":"/posts/english/"},{"categories":["English grammar"],"content":"词性 了解过了句子成分,那么这些句子成分是由哪些词来充当的呢? 这里对词性进行归纳 名词,nouns,表人和物 冠词,article,一般用于名词之前,帮助说明名词所指的人或物 代词,pronouns,代替人或物 形容词,adjective,形容人和物 数词,numerals,表数量 副词,adverbs,修饰动作或形容词 介词,prepositions,表示关系的词 叹词,interjection,表感叹 连词,conjunctions,连接词和句 ","date":"2021-04-17","objectID":"/posts/english/:3:0","tags":["English"],"title":"英语语法框架","uri":"/posts/english/"},{"categories":["English grammar"],"content":"简单句的组合 之前已经学习过五种基本简单句, 但是平常文章中并不是全都是简单句,还有长难句,其实是简单句的组合,概括下来只有两种句型,对应两种组合方式 复合句(compound sentence) –\u003e并列关系 复杂句(complex sentence) –\u003e 主从关系 ","date":"2021-04-17","objectID":"/posts/english/:4:0","tags":["English"],"title":"英语语法框架","uri":"/posts/english/"},{"categories":["English grammar"],"content":"复合句(compound sentence) 使用连词将多个简单句进行叠加 ","date":"2021-04-17","objectID":"/posts/english/:4:1","tags":["English"],"title":"英语语法框架","uri":"/posts/english/"},{"categories":["English grammar"],"content":"复杂句(complex sentence) 句子由主句和从句构成,主句只有一个,从句就是使用一个简单句来充当句子的成分,简单句充当的句子成分不同,分类也不同 从句的分类 简单句充当主语 –\u003e主语从句 简单句充当宾语 –\u003e宾语从句 简单句充当表语 –\u003e表语从句 简单句充当同位语 –\u003e同位语从句 简单句充当定语 –\u003e定语从句 简单句充当状语 –\u003e状语从句 ","date":"2021-04-17","objectID":"/posts/english/:4:2","tags":["English"],"title":"英语语法框架","uri":"/posts/english/"},{"categories":["English grammar"],"content":"谓语动词的时体气 之所以强调谓语动词,是因为它有三大特性 表示动作的时间,动作发生在过去或将来 表示动作的状态,动作已经完成或正在进行等 表示动作的假设,情感等,叫做动词的语气(语法上的语气) ","date":"2021-04-17","objectID":"/posts/english/:5:0","tags":["English"],"title":"英语语法框架","uri":"/posts/english/"},{"categories":["English grammar"],"content":"时态 谓语动词的时间和状态组合在一起就构成 了tense,也就是时态,你知道它们的关系是组合关系就可以由 4种时间 组合 4种状态 构成 16种时态 时间:现在,过去,将来,过去将来(过去的时间点的将来) 状态:一般,完成,进行,完成进行(完成而且继续) ","date":"2021-04-17","objectID":"/posts/english/:5:1","tags":["English"],"title":"英语语法框架","uri":"/posts/english/"},{"categories":["English grammar"],"content":"语气 英语动词语气分为三个部分 陈述语气(indicative mood) 祈使语气(imperative mood) 虚拟语气(subjunctive mood) 陈述语气:用来描述现实 祈使语气:用来表示命令或请求 绝大多数情况下,祈使语气就是 把你的命令/请求用第二人称(你)用一般现在时表达 把其中的你去掉,并保持动词原形 You never give up ! --\u003e Never give up ! 虚拟语气:用来描述你脑中的与现实相反的想象,主观意愿 这里将虚拟语气分为两类 与事实相反的假设 与现在相反: if + 过去式; would+动词原形 与过去相反: if + 过去完成式; would have + 过去分词 与将来相反: if + should + 动词原形; would + 动词原形 表达愿望,请求,建议,命令等 wish 与现在相反: wish + 过去式 与过去相反: wish + 过去完成式 与将来相反: wish + would/should/could/might + 动词原形 demand,suggest,indist,would rather… + (should) + 动词原形 虚拟语气可存在于不同类型的从句中,比如主语从句,表语从句,宾语从句,定语从句 ","date":"2021-04-17","objectID":"/posts/english/:5:2","tags":["English"],"title":"英语语法框架","uri":"/posts/english/"},{"categories":["English grammar"],"content":"助动词 谓语动词独自无法完成 否定,可能性,必须性等意思,需要另一类叫助动词(auxiliary verbs)的词来帮助完成任务 有以下几类助动词 be动词 帮助构成进行时 被动语态 do,did,does 一般现在时,过去时的否定和疑问 强调谓语动词 倒装 have,has 帮助构成完成时 will 帮助构成将来时 ","date":"2021-04-17","objectID":"/posts/english/:6:0","tags":["English"],"title":"英语语法框架","uri":"/posts/english/"},{"categories":["English grammar"],"content":"非谓语动词 一个简单句只能存在一个谓语动词体现时态,但是万一句子中出现了其他动词呢?这里我们把简单句中除开谓语动词的动词叫非谓语动词,它没有实体气,但是有4种变形,它几乎能替代所有从句,简化句子. 4种出现形式 动词不定式 –\u003e to do 现在分词 –\u003ev-ing=形容词 动名词 –\u003ev-ing 过去分词 –\u003ev-ed ","date":"2021-04-17","objectID":"/posts/english/:7:0","tags":["English"],"title":"英语语法框架","uri":"/posts/english/"},{"categories":["English grammar"],"content":"动词分类 英语语法核心就是 动词 ,上面说了那么多动词种类,但还不全,这里对所有动词进行归类,一共4类 实义动词:表示具体动作的词 及物动词:后面必须加宾语 不及物动词:不能直接加宾语,加介词再加宾语 系动词 状态:be动词 感官:feel,sound,smell 变化:get,become,turn,grow,fall 保持:keep,stand,remain,stay 表象:seem,appear 终止:prove 情态动词:是本身有一定词义,表示说话人主观态度的词,而且 不能单独出现,后面必须和实义动词/系动词一起构成谓语 情态动词的完成时表推测 can,could may,might must,have to should,ought to would need dare 助动词:帮助谓语动词一起构成否定,疑问,时态,语态等的词 be动词 do,did,does have,has will 注意\r\r所有的助动词和情态动词都能够帮助句子构成倒装,具体使用哪个助动词或者情态动词,要根据句子的时态和意思来决定\r\r ","date":"2021-04-17","objectID":"/posts/english/:8:0","tags":["English"],"title":"英语语法框架","uri":"/posts/english/"},{"categories":["English grammar"],"content":"思维导图总结 ","date":"2021-04-17","objectID":"/posts/english/:9:0","tags":["English"],"title":"英语语法框架","uri":"/posts/english/"},{"categories":["hugo"],"content":"使用hugo搭建网站 首先,这里介绍一下传统的网站搭建,你需要的是 一台服务器(一般是阿里云之类的云服务器,搭载的是Linux系统) 一个开源的网站框架或者模板(或选择自己开发网站前后端) 一个网站域名(域名国内需要备案,配置后域名可以访问网站,或者不用域名直接服务器公网ip访问网站) 你通过对云服务器进行端口,防火墙,ssh等一些配置,安装数据库,tomcat等软件后,将开源网站框架部署到云服务器上,域名可选或不选,这里你通过云服务器的公网ip就可以访问到网站,有域名将域名指向网站,添加dns解析就可以通过域名访问网站. 但是问题有以下几个 云服务器需要进行一系列繁琐的安全配置,常用端口可能需要经常更换,因为公网服务器一直在被世界各地的人攻击 服务器需要一直续费,不然到期后网站挂掉 图片,js等静态资源加载慢(服务器配置好忽略) 手动前后端管理 另一种选择 hugo hugo是一个基于go语言的框架,拥有最快速的静态网页生成速度,这里我们用它来搭建博客网站,使用github pages作为网站的托管,部署到vercel进行网站页面更新以及cdn加速,文章图片使用picgo+github仓库+jsdelivr组合图床,使用开源的utterances作为评论模块,使用algolia作为网站内部搜索引擎 这样做的好处 之后你可以专注写本地markdown文章,然后通过hugo生成html静态网页,使用git推送到github仓库 无需花时间在服务器上,无需续费网站一直存在,用户名.github.io永久域名访问网站 vercel帮你完成网页更新以及cdn网站加速 静态资源加速访问,图片在github仓库通过jsdelivr加速访问 写的博客直接发给别人也不需要打包图片,图片是超链接 拥有评论和搜索功能 基本上满足了我对于博客网站所有的需求,这里挂一张本网站在谷歌网页分析的评分,满分! 配置步骤 ","date":"2021-04-16","objectID":"/posts/hugo/:0:0","tags":["hugo"],"title":"Hugo 建站","uri":"/posts/hugo/"},{"categories":["hugo"],"content":"第一步创建仓库 创建github pages仓库,到github新建一个public仓库,仓库名为你的用户名.github.io,例如我的GitHub用户名为clearyup,那我的仓库名为clearyup.github.io ","date":"2021-04-16","objectID":"/posts/hugo/:1:0","tags":["hugo"],"title":"Hugo 建站","uri":"/posts/hugo/"},{"categories":["hugo"],"content":"第二步下载hugo hugoGitHub仓库在下载hugo 0.81.extended版本,将解压后的bin目录加载到系统path路径,cmd检验hugo是否安装成功 ","date":"2021-04-16","objectID":"/posts/hugo/:2:0","tags":["hugo"],"title":"Hugo 建站","uri":"/posts/hugo/"},{"categories":["hugo"],"content":"第三步 创建网站 在你的hugo目录下进入cmd 新建一个网站根目录 hugo new site myblog cmd中使用hugo命令创建第一篇文章 cd myblog hugo new posts/myfirst.md 这样在你的myblog/content/posts文件夹下就生成了myfirst.md文件,这个文件是根据myblog/archetypes目录下的default.md模板来创建新的md文件,你可以修改这个default.md文件作为新建文件的模板 注意!\r\r这里的文章头部有一个draft:true表示文章是草稿,使用hugo构建网站的时候不会将此文章生成静态html,建议设置成false\r\r 设置主题 你可以到hugo主题库选择一个主题,找到它的git仓库地址,然后使用git命令安装(git要设置好了代理) cd themes git submodule add https://github.com/luizdepra/hugo-coder.git themes/hugo-coder 这里是 git submodule add 主题仓库地址,你可以选择你喜欢的主题更换这个命令 配置主题 在myblog的config.toml中设置主题为你的主题,建议按照主题文档配置文件进行详细配置 theme = \"hugo-coder\" baseURL = \"https://你的github用户名.github.io\" cmd本地运行 hugo server 运行成功之后到http://localhost:1313/本地浏览网站 ","date":"2021-04-16","objectID":"/posts/hugo/:3:0","tags":["hugo"],"title":"Hugo 建站","uri":"/posts/hugo/"},{"categories":["hugo"],"content":"部署到github pages 生成静态网页 在myblog根目录下使用cmd命令 hugo -D 为确保所有文章都生成静态网页,使用hugo -D是草稿也生成静态网页 推送到远程仓库 cd public git init git add . git commit -m \"first commit\" git remote add origin 仓库地址 git push -u origin master 之后输入github用户名和密码就可以进行push,git有关配置参考我另一篇博客git配置 最后用户名.github.io访问你的网站 ","date":"2021-04-16","objectID":"/posts/hugo/:4:0","tags":["hugo"],"title":"Hugo 建站","uri":"/posts/hugo/"},{"categories":["hugo"],"content":"部署到Vercel 部署到vercel后网站拥有cdn加速,当你用git推送新文章到github仓库,vercel会帮你重新发布新页面,网站刷新后就可以看到新页面的内容 这里的仓库建议不设置为用户名.github.io这个仓库, 因为这个仓库是hugo生成的public文件 push 上来的, 没有config.toml配置文件, vercel不能识别为hugo类型的仓库, 就算你上传 config.toml文件到 用户名.github.io这个仓库,还是不能识别 建议新建一个blogBackup仓库,将hugo本地网站带有config.toml文件的根目录设为git仓库,推送到这个 blogBackup仓库, 这个是可以被vercel识别为hugo类型的仓库 ","date":"2021-04-16","objectID":"/posts/hugo/:5:0","tags":["hugo"],"title":"Hugo 建站","uri":"/posts/hugo/"},{"categories":["hugo"],"content":"第一步 注册Vercel账号,直接使用GitHub账号登录就可以了,然后允许访问所有仓库 ","date":"2021-04-16","objectID":"/posts/hugo/:5:1","tags":["hugo"],"title":"Hugo 建站","uri":"/posts/hugo/"},{"categories":["hugo"],"content":"第二步 选择Import Git Repository，选择blogBaskup这个仓库即可。在Environment Variables这里，添加一个变量，HUGO_VERSION = 0.80.0 以便正确编译,随后直接部署就可以了 ","date":"2021-04-16","objectID":"/posts/hugo/:5:2","tags":["hugo"],"title":"Hugo 建站","uri":"/posts/hugo/"},{"categories":["hugo"],"content":"第三步 如果你想自定义域名,在domain那里添加你要自定义的域名,更改域名的dns解析为vercel的就可以了 ","date":"2021-04-16","objectID":"/posts/hugo/:5:3","tags":["hugo"],"title":"Hugo 建站","uri":"/posts/hugo/"},{"categories":["hugo"],"content":"添加 .nojekyll 文件 避免 github 认为你使用了jekyll构建项目，添加 .nojekyll文件到用户名.github.io仓库, 否则可能受到 build failure 的邮件 ","date":"2021-04-16","objectID":"/posts/hugo/:6:0","tags":["hugo"],"title":"Hugo 建站","uri":"/posts/hugo/"},{"categories":["hugo"],"content":"重构GithubPages 主要是删除 public文件,使用hugo -D重新生成一个新的public ,再进行推送, 否则还是会重构失败,githubpages会显示404 ","date":"2021-04-16","objectID":"/posts/hugo/:7:0","tags":["hugo"],"title":"Hugo 建站","uri":"/posts/hugo/"},{"categories":["hugo"],"content":"参考视频 https://www.bilibili.com/video/BV147411M7C7 https://www.bilibili.com/video/BV1q4411i7gL/?spm_id_from=333.788.recommend_more_video.-1 ","date":"2021-04-16","objectID":"/posts/hugo/:8:0","tags":["hugo"],"title":"Hugo 建站","uri":"/posts/hugo/"},{"categories":["hugo"],"content":"algolia配置 博客本身支持lunr和algolia两种搜索引擎,为了高性能和网站加载速度我选择algolia lunr无需同步index.json文件,但是lunr需要加载本地js文件,这会使得网站加载缓慢,并且性能低(需要检索中文时需要一个较大的分词依赖库) algolia,高性能占用带宽低,网站加载快,配置麻烦,更新网站需要同步index.json文件 ","date":"2021-04-13","objectID":"/posts/algolia/:0:0","tags":["algolia"],"title":"Algolia","uri":"/posts/algolia/"},{"categories":["hugo"],"content":"配置步骤 ","date":"2021-04-13","objectID":"/posts/algolia/:1:0","tags":["algolia"],"title":"Algolia","uri":"/posts/algolia/"},{"categories":["hugo"],"content":"第一步 你需要在algolia官网注册,并create一个新的app,然后在你的hugo config.toml文件中配置algolia [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"algolia\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # LoveIt 新增 | 0.2.1 最大结果数目 maxResultLength = 10 # LoveIt 新增 | 0.2.3 结果内容片段长度 snippetLength = 50 # LoveIt 新增 | 0.2.1 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # LoveIt 新增 | 0.2.4 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] #index是algolia注册的名字,不是index.json,是个坑. #在algolia中 Duplication and Grouping Distinct设置为true，然后Attribute for Distinct设置为url，或者title index = \"\" appID = \"\" searchKey = \"\" ","date":"2021-04-13","objectID":"/posts/algolia/:1:1","tags":["algolia"],"title":"Algolia","uri":"/posts/algolia/"},{"categories":["hugo"],"content":"第二步 这时候你到博客搜索会发现algolia搜不到任何东西,这是因为algolia是根据hugo对你的网站生成的index.json进行搜索匹配文章的,你需要上传index.json文件,这会引发一个问题,你上传一次新文章或者修改一次文章就要重新到algolia控制台上传一次你的新生成的网站index.json文件,毫无疑问这是非常麻烦的,对此我们提供两种方法 使用algolia-automatic npm包,配置好后每次npm run algolia上传文件 自己根据官网写一个node.js脚本,运行node push_index.js命令行 我自己用的第二种,因为node push_index.js命令行可以加到我的文章git发布脚本和文章发布一起运行,而npm run命令会使得git部署发布脚本中断,因为它重开了一个bash,而且需要上传你的密钥到vercel,不安全. push_index.js脚本 indexName是你创建的algolia app名字 const algoliasearch = require('algoliasearch'); const appID = \" \" const indexName = \" \" const adminKey = \" \" const indexFile = \"./public/index.json\" const client = algoliasearch(appID, adminKey); const index = client.initIndex(indexName); const indexJson = require(indexFile); index.saveObjects(indexJson, { autoGenerateObjectIDIfNotExist: true }).then(({ objectIDs }) =\u003e { console.log(objectIDs); }); ","date":"2021-04-13","objectID":"/posts/algolia/:1:2","tags":["algolia"],"title":"Algolia","uri":"/posts/algolia/"},{"categories":["hugo"],"content":"第三步 将 node push_index.js命令行加到deploy.sh脚本中,和git命令一起执行,完成git仓库push,网站页面更新,以及algolia的index.json更新 因此你在新文章发布后,algolia也有了最新的index.json脚本,新文章不会出现检索不到的情况 注意!\r\r你最好将push_index.js文件加入到.gitignore文件中,因为其中的密钥上传到仓库可能不安全!\r\r ","date":"2021-04-13","objectID":"/posts/algolia/:1:3","tags":["algolia"],"title":"Algolia","uri":"/posts/algolia/"},{"categories":["git"],"content":"git设置 通过设置git代理,你clone和push的操作处理速度会由20kb/s变成7.8Mb/s,因此有代理的设置这个很有必要 注意!\r\r以后每次使用git命令或者git脚本记得代理是开启的\r\r ","date":"2021-04-12","objectID":"/posts/gitproxy/:0:0","tags":["git"],"title":"Gitproxy","uri":"/posts/gitproxy/"},{"categories":["git"],"content":"设置代理 ","date":"2021-04-12","objectID":"/posts/gitproxy/:1:0","tags":["git"],"title":"Gitproxy","uri":"/posts/gitproxy/"},{"categories":["git"],"content":"全局代理 git config --global http.proxy 127.0.0.1:7890 这里的7890是clash的代理端口,如果你不是clash,设置你自己的代理端口 ","date":"2021-04-12","objectID":"/posts/gitproxy/:1:1","tags":["git"],"title":"Gitproxy","uri":"/posts/gitproxy/"},{"categories":["git"],"content":"局部代理 在仓库内使用 git config --local http.proxy 127.0.0.1:7890 ","date":"2021-04-12","objectID":"/posts/gitproxy/:1:2","tags":["git"],"title":"Gitproxy","uri":"/posts/gitproxy/"},{"categories":["git"],"content":"取消设置代理 ","date":"2021-04-12","objectID":"/posts/gitproxy/:2:0","tags":["git"],"title":"Gitproxy","uri":"/posts/gitproxy/"},{"categories":["git"],"content":"取消全局代理 git config --global --unset http.proxy ","date":"2021-04-12","objectID":"/posts/gitproxy/:2:1","tags":["git"],"title":"Gitproxy","uri":"/posts/gitproxy/"},{"categories":["git"],"content":"取消局部代理 git config --local --unset http.proxy ","date":"2021-04-12","objectID":"/posts/gitproxy/:2:2","tags":["git"],"title":"Gitproxy","uri":"/posts/gitproxy/"},{"categories":["git"],"content":"设置用户名密码 hugo每次push都需要输入用户名密码,我们可以生成用户名密码信息,以后都不需要输入 ","date":"2021-04-12","objectID":"/posts/gitproxy/:3:0","tags":["git"],"title":"Gitproxy","uri":"/posts/gitproxy/"},{"categories":["git"],"content":"具体代码 git config --global credential.helper store 在你的本地仓库文件夹执行这条命令,然后push一次,输入一次用户名和密码,以后都不需要了 ","date":"2021-04-12","objectID":"/posts/gitproxy/:3:1","tags":["git"],"title":"Gitproxy","uri":"/posts/gitproxy/"},{"categories":["git"],"content":"设置换行处理 git config --global core.autocrlf false ","date":"2021-04-12","objectID":"/posts/gitproxy/:4:0","tags":["git"],"title":"Gitproxy","uri":"/posts/gitproxy/"},{"categories":["git"],"content":"git bash配置 在 C:\\Users\\y2010\\.minttyrc中修改 BoldAsFont=-1 CursorType=block CursorBlinks=no Font=Fira Code FontHeight=13 Transparency=low FontSmoothing=default Locale=C Charset=UTF-8 Columns=88 Rows=26 OpaqueWhenFocused=no Scrollbar=none Language=zh_CN ForegroundColour=131,148,150 BackgroundColour=0,43,54 CursorColour=220,130,71 BoldBlack=128,128,128 Red=255,64,40 BoldRed=255,128,64 Green=64,200,64 BoldGreen=64,255,64 Yellow=190,190,0 BoldYellow=255,255,64 Blue=0,128,255 BoldBlue=128,160,255 Magenta=211,54,130 BoldMagenta=255,128,255 Cyan=64,190,190 BoldCyan=128,255,255 White=200,200,200 BoldWhite=255,255,255 BellTaskbar=no Term=xterm FontWeight=400 FontIsBold=no ","date":"2021-04-12","objectID":"/posts/gitproxy/:5:0","tags":["git"],"title":"Gitproxy","uri":"/posts/gitproxy/"},{"categories":null,"content":"个人说明 引言\r\r这是一个使用 hugo+ github pages + vervel搭建的个人静态博客,其实有很多其他的选择,但是hugo的静态页面构建速度是最快的,因此选择了hugo\r\r 下面是博客的介绍 此博客主题使用的是LoveIt,本地最好使用hugo_extended版本,部署到vercel注意加上variable environment HUGO_VERSION 0.80.0 评论系统是utterances 搜索基于algolia 图床使用picago+github+jsdelivr 其中jsdelevr路径为: https://cdn.jsdelivr.net/gh/用户名/图床仓库名 域名使用freenom上的域名 后续我会发布更新更多技术博客,欢迎访问和交流. ","date":"2021-04-07","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"}]