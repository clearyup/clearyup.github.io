# Golang


# go语法特殊点
- 给新的短变量初始化时可使用:=来自动推导，一般在函数内部使用
- 变量数据交换可以直接a, b = b, a
- 代码行尾不需要分号
- 匿名变量下划线 _ 比如函数定义时是返回两个值的，你使用时只需要返回一个，第二个就可以用下划线，常用于数据库返回的数据处理丢弃不需要的数据
- 局部变量和全局变量，打印结果时，就近原则
- 特殊常量iota，使用const定义常量用iota赋值时，第一次是0，多一个常量开始依次加1，没有赋值的常量默认用上一行的常量值初始化
- switch的fallthrough关键字可以强制执行后面的case语句，不会判断下一条case语句是否为true
- 函数可变参数，例如arg... int表示函数接收若干个int类型的参数
- 用defer关键字延迟一个函数的执行，一个defer会让函数最后执行，多个defer，先定义的defer会进入栈底，后定义的defer会在栈顶，然后出栈
- 匿名函数自己调用自己，函数定义后面加两个小括号就行
- 回调函数，将一个函数作为另一个函数的参数
- 闭包函数，一个外层函数中，有内层函数，该内层函数中，会操作外层函数的局部变量，并且该外层函数的返回值就是这个内层函数。这个内层函数和外层函数的局部变量，称为闭包结构，这时局部变量的生命周期会发生改变，正常的局部变量会随着函数的调用而创建，随着函数的结束而销毁，但是闭包结构中的外层函数的局部变量并不会随着外层函数的结束而销毁，因为内层函数还在继续使用
- if中定义的局部变量在else中也可以使用
- 指向结构体的指针访问成员应该是 (* p). user,但是可以简写为p.user, 隐式间接访问

# go语法不同点
- 程序从main包开始执行
- 每个包都有一个init函数来初始化包，main包有一个init函数和main函数，程序执行时先从main包import的包开始加载，要加载的包init函数执行完后回调，程序结构是一个main包一个main函数是程序入口，其他包import到main包里
- slice切片，动态数组，没有大小的数组，可以随着元素追加改变容量大小
- slice切片传递的是数组的指针，是按引用传递，普通数组是按照值传递的，传递的是一份副本，不会更改原数据
- slice切片零值是nil，nil切片的长度和容量为0且没有底层数组，slice切片有len和cap，长度和容量，每次容量满了会将容量扩大一倍
- map，var r map[int]string表示key是int类型，value是string类型的键值对
- 如果类名（结构体）大写，那么其他包也可以调用这个类，小写就是包内使用
- 继承直接在子类中写父类的类名就可以继承父类的方法和成员
- 多态是用interface实现的，interface本质是一个指针
- 万能类型空接口interface{ }，常用基本数据类型都实现了interface{ }，为了区分引用的底层数据类型是什么，go给interface提供了类型断言机制
- 变量的内置结构pair，变量包含type和value的一对pair结构，通过类型断言可以反向推导，反射就是通过pair结构，能通过type和value某一个反射出另一个。也可以使用反向单引号对结构体属性打标签，通过反射可以获取到tag，主要用于json数据结构体 
- goroutine协程，进程切换是有成本的，使用协程切换成本小


